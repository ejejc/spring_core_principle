1. LOC - 제어의 역전
기존 : 클라이언트가 직접 구현 객체를 생성하고 실행까지 담당
AppConfig 등장 : 클라이언트는 자신의 로직을 실행하는 역활만 담당

즉, 프로그램의 제어의 흐름은 외부에서 관리하고 있다 -> 이것이 제어의 역전

프레임워크 vs 라이브러리
프레임워크
- 내가 작성한 코드를 제어하여 대신 실행
라이브러리
- 내가 작성한 코드가 직접 제어의 흐름을 담당

2. DI - 의존관계 주입
정적인 클래스 의존관계
- import문만 보고 알 수 있다.
동적인 클래스 의존관계
- 프로그램이 실행하는 시점에 결정하는 동적인 클래스 의존관계
- 실제 생성된 객체 인스턴스의 참조가 연결된 의존관계

즉, 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존 관계 주입이라고 한다.
의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
의존관계 주입을 사용하면 정적인 클래스 다이어그램 수정 없이 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

3. IOC 컨테이너, DI 컨테이너
AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IOC 컨테이너 또는 DI 컨테이너 라고 한다.
의존 관계 주입에 초점을 맞추어 DI 컨테이너라고 한다.

4. 스프링 컨테이너 - ApplicationContext
기존에는 AppConfig를 사용하여 직접 객체를 생성하여 의존성을 주입했지만
스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정 정보로 사용한다.
여기서 @Bean이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.
이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라고 한다.

메서드 명을 스프링 빈의 이름으로 사용한다.
이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈을 찾으면 된다.

ApplicationContext
= 인터페이스이다. 즉, 다형성 적용되어 있다.
= 스프링 컨테이너는 xml기반 또는 어노테이션 기반의 자바 설정 클래스로 만들 수 있다. (요즘은 거의 어노테이션!)
= new AnnotationConfigApplicationContext는 ApplicationContext의 구현체이다.

스프링은 빈을 생성하고 의존관계를 주입하는 단계가 나뉘어진다.
하지만 이렇게 자바코드를 사용하게 되면 빈응 등록하면서 생성자를 호출하여 의존 관계 주입도 한번에 처리된다.

----------------------------------------------------------------------------------------------------------------
BeanFactory
- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역활을 담당한다.
- getBean() 을 제공

Application Context
- BeanFactory의 기능을 모두 상속받아서 제공한다.
- BeanFactory와의 차이점은 무엇일까?
    - 애플리케이션 개발 시, 수 많은 부가 기능이 필요하다. (이 부가 기능을 Application Context가 가지고 있다.)

정리 !!!
- applicationContext = 빈의 관리 기능 + 편리한 부가기능을 제공
- beanFactory를 직접 사용할 일은 거의 없으며 부가기능이 포함된 applicationContext를 많이 사용한다.
- beanFactory나 applicationContext를 스프링 컨테이너라고 하며, applicationContext만 사용한다 정도만 알고 있자 !!

----------------------------------------------------------------------------------------------------------------
- 빈의 메타 정보

spring은 beanDefinition을 통해 스프링 빈의 메타 정보를 추상화 한다.

beanDefinition은 applicationContext의 구현체들의 필드에 beanDefinition을 가져오는 Reader가 존재한다.
해당 Reader을 통해 AppConfig.class or AppConfig.xml을 읽어들이는 것이다.

----------------------------------------------------------------------------------------------------------------

- 웹 어플리케이션과 싱글톤
대부분의 스프링 애플리케이션은 웹 애플리케이션이다.
물론 웹이 아닌 애플리케이션도 얼마든지 개발 가능 - ex. spring-batch
웹 어플리케이션은 보통 여러 고객이 동시에 요청을 한다.

예를 들어, 고객이 3명이 요청이 올때마다 객체가 계속 생성된다면..?
jvm 메모리가 점점 늘어나게 된다. -> 즉, 메모리 낭비가 심하다.

해결 방안은 해당 객체가 딱 1개만 생성하고 이를 공유하도록 설계하자! -> 싱글톤패턴 적용

- 싱글톤 패턴
클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인패턴이다.
싱글톤 패턴을 적용하면 호출할 때마다 같은 인스턴스가 반환된다.

싱글톤 패턴을 적용하면 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다.
하지만 다음과 같은 수 많은 문제점들을 가지고 있다.

- 싱글톤 패턴의 문제점
싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다 ..
구체클래스.getInstance() 로 꺼내야 해서 클라이언트가 구체 클래스를 의존하게 된다. -> DIP, OCP 위반
테스트하기 어렵다.
결론적으로 유연성이 떨어진다.
그래서 안티패턴으로 불리기도 한다.

하지만 스프링 컨테이너는 씽글톤 패턴의 문제점을 모두 해결해주고 객체를 하나로 관리해준다 !!!

- 싱글톤 컨테이너
스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리한다.
지금까지 우리가 학습한 빈이 바로 싱글톤으로 관리되는 빈이다.

클라이언트가 요청이 올때마다 스프링 컨테이너 덕분에 이미 만들어진 객체를 공유하여 효율적으로 재사용 할 수 있다.

참고: 스프링의 기본 등록 방식은 싱글톤이지만 요청할 때마다 새로운 객체를 생성하여 반환하는 기능도 제공 한다 -> 빈 스코프

- 싱글톤 방식의 주의점
싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든 객체 인스턴스를 하나만 생성하여 공유하는 싱글톤 방식은
여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.

무상태(stateless)로 설계해야한다.
즉, 특정 클라이언트가 값을 수정하게 하지 말고, 읽기만 하는 것이 좋다.
필드 대신에 지역변수, 파라미터 등으로 사용해야 한다.
스프링 빈은 무조권 무상태로 유지해야 한다 !!

---------------------------------------------------------------------------------------------------

@Configuration과 싱글톤

확인해보면 AppConfig.class에 등록되어 있는 memberRepository 인스턴스는 모두 같은 인스턴스가 공유되어 사용된다.

AppConfig가 순수한 클래스라면
class hello.core.AppConfig 이렇게 나와야 한다.
하지만 예상과 다르게 $$EnhancerBySpringCGLIB 가 나오면 이것은 내가 만든 클래스가 아니라 cglib라는 바이트코드 조작 라이브러리를 사용해서 appconfig 클래스를 상속받은 임이의 다른 클래스를 만들고 그 클래스를 스프링 빈으로 등록한 것이다.
@Bean이 붙어 있는 메서드 마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다.
덕분에 싱글톤이 보장되는 것이다.

만약 @Configuration 없이 @Bean만 등록을 한다면 빈이 등록되기는 하지만 싱글톤이 보장되지 않는다.

---------------------------------------------------------------------------------------------------

- 컴포넌트 스캔과 의존관계 자동 주입 시작하기
지금까지 스프링 빈을 등록할 때에는 @Bean이나 xml의 <bean> 등을 통해서 설정 정보에 직접 등록하여 빈을 나열했다.
빈이 수백개가 되면 일일이 등록하기도 귀찮고 반복이 된다 .. !!!
그래서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
또 의존 관계도 자동으로 주입하는 @Autowired도 제공한다.

컴포넌트 스캔은 말 그대로 @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
@Configuration가 컴포넌트 스캔 대상이 된 이유는 @Configuration의 소스 코드를 열어보면 @Component 어노테이션이 붙어있기 때문이다.

이전에 appconfig에서는 @Bean으로 직접 설정 정보를 작성했고, 의존관계도 직접 명시했다.
이제는 이런 설정 정보 자체가 없기 때문에 의존관계 주입도 이 클래스 안에서 해결해야 한다.
@Autowired 는 이러한 의존 관계를 자동으로 주입해준다.
즉, 스프링 컨테이너가 자동으로 스프링 빈으로 찾아서 주입하며 기본 조회 전략은 같은 타입의 빈을 찾아서 주입한다.
생성자에 파라미터가 많아도 다 찾아서 자동으로 주입해준다.

---------------------------------------------------------------------------------------------------

basePackages
- 탐색할 패키지의 시작 위치를 지정한다.
- 이 패키지를 포함해서 하위 패키지를 모두 탐색한다.
basePackageClasses
- 지정한 클래스의 패키지를 탐색 위치로 지정한다.
별도로 지정하지 않으면
- @ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다.

* 권장하는 방법 *
- 패키지 위치를 지정하지 않고, 설정 정보 클래스의 위치를 프로젝트의 최상단에 두는 것이다.

참고로 스프링 부트를 사용하게 되면 스프링 부트의 대표 시작 정보인 @SpringBootApplication을 프로젝트 시작 루트 위치에 두는 것이 관례이다.
그 이유는 해당 설정 안에 @ComponentScan이 들어있기 때문이다.

컴포넌트 스캔의 대상
- @Component
- @Service
- @Controller
- @Repository
- @Configuration

----------------------------------------------------------------------------------------------------------------

중복 등록과 충돌
- 자동 빈 등록 vs 자동 빈 등록
- 자동 빈 등록 vs 수동 빈 등록

1. 자동 빈 등록 vs 자동 빈 등록
- ConflictingException 발생

2. 자동 빈 등록 vs 수동 빈 등록
- 이 경우에는 수동 빈이 자동 빈을 오버라이딩하여 우선권을 가져가게 된다.
- 보통 수동 빈을 우선 순위를 가지고 가는 것보다는 개발자가 실수를 한 경우가 더 많으며
  이 경우에는 원인을 찾기 힘들다.
  그래서 최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류를 발생하도록 기본 값 변경

----------------------------------------------------------------------------------------------------------------

다양한 의존관계 주입

1. 생성자 주입
- 생성자 호출 시점에 딱 1번만 호출되는 것이 보장한다.
- 불변, 필수 의존관계에 사용
- 생성자가 딱 한 1개만 있다면 @Autowired를 생략해도 된다.
2. 수정자 주입 (setter 주입)
- setter 라고 불리는 필드의 값을 변경하는 수정자 메서드를 통해 의존관계 주입
- 선택, 변경 가능성이 있는 의존관계에서 사용
3. 필드 주입
- DI 프레임워크가 없으면 아무것도 할 수 없다.
- 즉, 외부에서 변경이 불가능하여 테스트 하기 힘들다는 치명적인 단점 존재
    - 테스트 시에는 인스턴스를 넣어줘야 하는데 넣어줄 방법이 없어 결국 setter을 열어줘야 한다 -> 수정자 주입이 됟다다
4. 일반 메서드 주입
- 일반적으로 잘 사용하지 않는다.

어쩌면 당연한 이야기이지만 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다.
즉, 스프링 빈이 아닌 Member 같은 클래스에서 @Autowired를 적용하여도 아무런 동작이 없다.

----------------------------------------------------------------------------------------------------------------

옵션 처리

주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
그런데 @Autowired 만 사용하면 required 옵션의 기본값이 true로 되어 있어서 자동 주입 대상이 없으면 오류 발생

자동 주입 대상을 옵션으로 처리하는 방법은 다음과 같다.
- @Autowired(required = false)
- @Nullable
- Optional<>

@Nullable과 Optional<> 은 스프링 전반에 걸쳐서 지원한다.
예를들어 생성자 자동 주입에서 특정 필드만 제외하고 싶을 때, @Nullable을 사용하면 된다.

----------------------------------------------------------------------------------------------------------------

생성자 주입을 선택하라 !!!

1. 불변
- 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.
- 수정자 주입을 사용하게 되면 변경될 가능성이 있지만 생성자 주입은 객체 생성 시 딱 1번만 호출되므로 불변 객체로 설계할 수 있다.
- 필드에 final 키워드를 넣을 수 있다.
- 컴파일 오류가 세상에서 제일 빠르구 좋은 오류다
참고 : 수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로 필드에 final 키워드를 사용할 수 없다.

----------------------------------------------------------------------------------------------------------------

롬복과 최신 트랜드

1. @RequiredArgContructor
- final이 붙은 필드들을 가지고 생성자를 만들어 준다.

----------------------------------------------------------------------------------------------------------------

2개 이상의 같은 타입 빈 등록 시

예를들어,
private final DiscoutPolicy discountPolicy;
에서 의존관계 주입을 기존에는 FixDiscountPolicy 만 bean으로 등록되어 있었다.

하지만 DiscountPolicy도 bean으로 등록하게 되면
spring은 expected single matching bean but found 2: fixDiscountPolicy, rateDiscountPolicy
라는 오류를 반환하게 된다.
즉, 하나의 빈을 기대했는데 두개의 빈이 발견되었다.

만약, 이를 해결하기 위해 하위 타입으로 지정하면 되지만 DIP를 위반하고 유연성이 떨어진다.

해결 방법
1. @Autowired 필드 명 매칭
- @Autowired는 타입 매칭을 시도하고, 이때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.
- 즉 DiscountPolicy의 타입의 빈이 2개 이상이면 private DiscountPolicy fixDiscountPolicy // 이런식으로 필드 명을 변경해주면 해당 타입으로 주입이 된다.
2. @Qualifier 사용
- 빈 주입 시, @Qualifier() 을 붙여주고 등록한 이름을 적어준다.
3. @Primary 사용
- 빈이 여러개 조회될때 primary가 붙은 빈을 1순위로 매칭해준다.
4. 활용
보통 메인이 되는 빈을 @Primary를 적용하고 서브가 되는 빈은 @Qualifier을 지정해서 명시적으로 획득하는 방식으로 많이 사용

----------------------------------------------------------------------------------------------------------------

어노테이션 직접 만들기

- @Qualifier 사용 시, @Qualifier("~") 문자를 넣어줘야 하는데 문자는 컴파일 시 오류가 나지 않는다.
  그래서 보통 어노테이션을 만들어서 사용한다.
- 어노테이션은 상속이라는 개념이 없다.

----------------------------------------------------------------------------------------------------------------

조회한 빈이 모두 필요할 때, List, Map 사용

- 의도적으로 해당 타입의 스프링 빈이 다 필요한 경우가 있다.
ex.
- 예를들어, 할인 서비스를 제공하는데, 클라이언트가 할인 조유를 선택할 수 있다고 가정해보자.
  스프링을 사용하면 소위 말하는 전략패턴으로 매우 간단하게 구현 할 수 있다.

----------------------------------------------------------------------------------------------------------------

자동, 수동의 올바른 실무 운영의 기준

- 편리한 자동 기능을 기본으로 사용하자 !
- 자동 빈 등록을 사용해도 OCP, DIP를 지킬 수 있다.

그렇다면 수동 빈 등록은 언제 사용하면 좋을까 ?
업무 로직 빈
- 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 repository들이 모두 업무 로직이다.
- 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.
기술 지원 빈
- 기술적인 문제나 AOP를 처리할 때 주로 사용된다.
- 데이터베이스 연결이나, 공통 로그 처리 처럼 업무 로직을 지원하기 위한 하부 기술 및 공통 기술을 의미한다.

업무 로직 빈은
숫자도 매우 많고, 개발 패턴이 어느정도 유사하다. 이런경우 자동 기능을 적극적으로 사용하는 것이 좋다.
보통 문제가 발생하였을 때, 어디에서 발생했는지 파악하기 쉽다.

기술 지원 빈은
업무 로직과 비교해서 그 수가 매우 적고, 보통 애플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다.
기술 로직은 문제가 발생하였을 때 적용이 잘되고 있는지 아닌지 조차 파악하기 어려운 경우가 많다.
따라서 기술 지원 로직들은 가급적 수동 빈 등록을 사용해서 명확하게 들어내느 것이 좋다.

[비즈니스 로직 중에서 다형성을 적극적으로 활용할 때]
- 예를들어 의존관계 자동 주입 - List, Map일 경우, 어떤 빈들이 조회되는지 한눈에 파악하기 쉬운가 ?
  자동 등록을 사용하고 있기 때문에 파악하려면 여러 코드를 찾아봐야 한다.
- 이런 경우 수동으로 빈을 등록하거나, 특정 패키지에 같이 묶어 두는게 좋다.

ex.
DiscountPolicyConfig에서 RateDiscountPolciy와 FixDiscountPolicy 빈 등록

정리 !!!
- 편리한 자동 기능을 기본으로 사용하자 !
- 직접 등록하는 기술 지원 객체는 수동 등록 !
- 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민 !

----------------------------------------------------------------------------------------------------------------

빈 생명주기 콜백

NetworkClient 생성자를 보면 url 정보 없이 connect가 호출되는 것을 확인할 수 있다.
너무 당연한 이야기이지만, 객체를 생성하는 단계에는 url이 없고,
객체를 생성한 다음에 외부에서 수정자 주입을 통해서 setUrl()이 호출되어야 url이 존재하게 된다.

스프링 빈은 간단하게 다음과 같은 라이프사이클을 가진다.
객체 생성 -> 의존 관계 주입 - 생성자 주입은 예외

스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다.
따라서 초기화 작업은 의존 관계 주입이 모두 완료되고 호출해야 한다.
그러면 개발자가 의존관계 주입이 모두 완료된 시점을 어떻게 알 수 있을까?

스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다.
또한 스프링은 스프링 컨테이너가 종료되기 직전에 빈 소별 콜벡을 준다.
따라서 안전하게 종료 작업을 진행 할 수 있다.

- 스프링 빈의 이벤트 라이프 사이클 -
- 싱글톤의 경우
스프링 컨테이너 생성 > 스프링 빈 생성 > 의존관계 주입 > 초기화 콜백 (의존관계 주입 다 되었으니 이제 초기화 해도 되!)
> 애플리케이션 사용 > 소멸전 콜백 > 스프링 종료

초기화 콜백 : 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
소멸전 콜백 : 빈이 소멸되기 직전에 호출

? 그렇다면 url을 생성자 시점에 초기화 해주면 되는게 아닌가 ?
*참고* : 객체의 생성과 초기화를 분리하자
- 생성자는 필수 정보를 받고, 메모리를 할당하여 객체를 생성하는 책임을 가진다.
- 반면에 초기화는 이렇게 생성된 값을 활용해서 외부 커넥션을 연결하는 무거운 동작을 수행한다.
- 따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는
  객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다.
  물론 초기화 작업이 내부 값들을 약간 변경하는 정도로 단순한 경우에는 생성자에서 한번에 다 처리하는게 나을 수도 있다.

스프링은 어떻게 콜백을 지원할까 ?
- 인터페이스
- 설정 정보에 초기화 메서드, 종료 메서드 지정
- @PostConstruct, @PreDestory 어노테이션 지원

1. 인터페이스
- 출력 결과를 보면 afterPropertiesSet() 메소드는 빈 주입이 모두 완료된 이후에 호출되는 것을 알 수 있으며
- destroy() 메소드는 스프링 컨테이너 종료가 호출되자 소멸 메소드가 호출 된 것도 확인 할 수 있다.

* 초기화, 소멸 인터페이스의 단점
- 이 인터페이스는 스프링 전용 인터페이스 이므로, 코드가 스프링 전용 인터페이스에 의존한다.
- 초기화, 소멸 메서드의 이름을 변경할 수 없다.
- 내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.

해당 방법은 스프링 아주 초창기에 나온 방법으로 지금은 잘 사용하지 않는다

2. 설정 정보에 초기화 메서드 종료 메서드 지정
- 메서드 이름을 지정할 수 있다,
- 스프링 빈이 스프링 코드에 의존하지 않는다.
- 코드가 아닌 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메소드를 지정할 수 있다.
- @Bean의 종료 메소드는(destroyMethod) 는 기본값이 (inferred) (주문)으로 등록되어 있다.
  이 기능은 close, shutdown이라는 이름의 메서드를 자동으로 호출한다. 이름 그대로 종료 메서드를 주문해서 호출해준다.
  따라서 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 잘 동작한다.

3. 어노테이션 @PostConstruct, @PreDestory
- 최신 스프링에서 가장 권장하는 방법이다.
- 스프링 종속 기술이 아닌 자바 표준이라 스프링이 아닌 컨테이너에서도 동작한다.
- 유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다.
  외부 라이브러리를 초기화, 종료 해야 하면 @Bean의 기능을 사용하자!

----------------------------------------------------------------------------------------------------------------

빈 스코프란 ?

스프링은 다양한 스코프를 지원한다.
- 싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넣은 범위의 스코프이다.
- 프로토타입 : 스프링컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 이후에는 관리하지 않는다.
- 웹 관련 스코프
    request : 웹 요청이 들어오고 나갈때까지 유지되는 스코프이다.
    session : 웹 세션이 생성되고 종료될때 까지 유지되는 스코프이다.
    application : 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프이다.

프로토타입 스코프

- 싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환한다.
  반면에 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.

!! 핵심
여기서 핵심은 스프링 컨테이너는 프로토타입을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것이다.
클라이언트에 빈을 반환하고 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다.
프로토타입 빈을 관리할 책임은 클라이언트에 있다. 즉, @PreDestory 같은 종료 메소드가 호출되지 않는다.

- 싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드가 실행되지만,
  프로토타입 스코프의 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고 초기화 메서드도 실행된다.
- 프로토타입 빈을 2번 조회했으므로 완전히 다른 스프링 빈이 생성되고, 초기화도 2번 실행된 것을 알 수 있다.
- 싱글톤 빈은 스프링 컨테이너가 관리하기 때문에 컨테이너가 종료될 때 빈의 종료 메서드가 실행되지만,
  프로토타입 빈은 스프링 컨테이너 생성과 의존관계 주입 그리고 초기화까지만 관여하고 더는 관리하지 않는다.
  따라서 프로토타입 빈은 스프링 컨테이너가 종료될 때 @PreDestory 같은 종료 메서드가 전혀 실행되지 않는다.

----------------------------------------------------------------------------------------------------------------

프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

싱글톤 타입 안에 프로토타입 빈을 선언한 후, 싱글톤 타입 생성 시점에 프로토타입 빈을 주입받으면
프로토타입 빈의 주소값을 할당하게 된다.

client1이 logic() 메소드를 호출 count: 1이 된다. (count는 프로토타입의 필드)
client2가 logic() 메소드를 호출 count: 2가 된다.

즉 프로토타입은 호출할때마다 새로 생성되는 scope지만,
싱글톤 내부에 정의되어 있는 프로토타입은 싱글톤이 생성될 때 프로토타입의 의존관계를 주입하므로
같은 프로토타입을 사용하게 되는 것이다.

아마 원하는 것이 이런 것이 아니라, 프로토타입 빈을 주입 시점에 새로 생성하는게 아니라,
사용할 때마다 새로 생성해서 사용하는 것을 원할 것이다.

----------------------------------------------------------------------------------------------------------------

프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결

- 싱글톤 빈과 프로토타입 빈을 함께 사용할 때, 어떻게 하면 사용할 때 마다 새로운 프로토타입 빈을 생성할 수 있을까 ?

의존관계를 외부에서 주입 받는게 아니라 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 조회 라고 한다.
지금 필요한 기능은 지정한 프로토타입 빈을 컨테이너에서 대신 찾아주는 DL 정도의 기능만 제공하는 무엇인가만 있으면 된다.

실행해보면 prototypeBeanProvider.getObject()를 통해서 항상 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다.
스프링이 제공한느 기능을 사용하지만, 기능이 단순하므로 테스트 및 mock 코드를 만들기는 편하다.

하지만 스프링에 의존적이다.

이를 해결한 방법이 javax.provider 이다.
이는 스프링에 의존적이지 않으며 DL 정도의 기능만 제공한다.
하지만 별도의 라이브러리가 필요하다.

정리 !!!
그러면 프로토타입 빈은 언제 사용할까 ?
매번 사용할때마다 새로운 객체가 필요하면 사용하면 된다.
그런데 실무에서는 싱글톤 빈으로 대부분의 문제를 해결할 수 있으므로, 프로토타입 빈을 직접적으로 사용하는 경우는 굉장히 드물다.
